# -*- coding: utf-8 -*-
"""brocode_numpy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VyBWJRw0zsNxDJTlZUyfDhp2khTYpFfY
"""

import numpy as np
print(np.__version__)

my_list = [1,2,3,4]
my_list = my_list * 2
print(my_list) #[1, 2, 3, 4, 1, 2, 3, 4]

arr1 = np.array([1,2,3,4,5])
array = arr1*2
print(array)       #[ 2  4  6  8 10]

print(type(array)) #<class 'numpy.ndarray'>

import numpy as np
array = np.array('A')
print(array.ndim) #zero dimensional array -> output: 0

array = np.array(['A','B','C','D'])
print(array.ndim) #one dimensional array -> output: 1

array = np.array([['A','B','C'],
                  ['E','F','G'],
                  ['H','I','J']]) #its a 2d array -> output: 2
print(array.ndim)

array = np.array([[['A','B','C'],['D','E','F'],['G','H','I']],
                  [['J','K','L'],['M','N','O'],['P','Q','R']],
                  [['S','T','U'],['V','W','X'],['Y','Z','_']]])
print(array.ndim) #array is 3d ->output: 3
print(array.shape) #3layers, 3rows, 3columns-> output: (3,3,3)
#chain indexing:
print(array[0][0][0]) # output: A
print(array[1][2][2]) # output: R
#multidimensional indexing: faster than chain indexing
print(array[0,0,0]) # A -> zero layer,0row, 0column
print(array[1,1,1]) # N
print(array[2,0,0]) # S
print(array[0,1,2]) #F

#practice
#we access the words
word = array[0,1,0] + array[0,1,1] + array[0,1,1] + array[1,2,0] + array[0,0,0] + array[1,0,1]
print(word)
# DEEPAK

#slicing:
import numpy as np
arr = np.array([[1,2,3,4],
                [5,6,7,8],
                [9,10,11,12],
                [13,14,15,16]])
#array[start:end:step]
print(arr[0])  #[1 2 3 4]
print(arr[1])   #[5 6 7 8]
#we can also use negativi indexing
print(arr[-1])  #[13 14 15 16]
print(arr[-2])   #[9 10 11 12]

print(arr[0:3])  #ending index is exclusive
#[[ 1  2  3  4]
#  [ 5  6  7  8]
#  [ 9 10 11 12]]

print(arr[1:]) #if we want everything then we take ':'
# [[ 5  6  7  8]
#  [ 9 10 11 12]
#  [13 14 15 16]]

print(arr[0:4:2]) #gives every 2nd row
# [[ 1  2  3  4]
#  [ 9 10 11 12]]
print(arr[::2]) #same output

#rows in reverse order
print(arr[::-1])
# [[13 14 15 16]
#  [ 9 10 11 12]
#  [ 5  6  7  8]
#  [ 1  2  3  4]]
print(arr[::-2]) #for every 2nd row in reverse
# [[13 14 15 16]
#  [ 5  6  7  8]]

# column selection
# first index is for row , second for column
print(arr[:,1]) #all row and first column -> [[2 6 10 14]]

print(arr[:,0:3]) #all rows + 3 columns
# [[ 1  2  3]
#  [ 5  6  7]
#  [ 9 10 11]
#  [13 14 15]]

print(arr[:,1:])
# [[ 2  3  4]
#  [ 6  7  8]
#  [10 11 12]
#  [14 15 16]]

print(arr[:,::2])
# [[ 1  3]
#  [ 5  7]
#  [ 9 11]
#  [13 15]]

print(arr[:,1::2])
# [[ 2  4]
#  [ 6  8]
#  [10 12]
#  [14 16]]

print(arr[:,::-1])
# [[ 4  3  2  1]
#  [ 8  7  6  5]
#  [12 11 10  9]
#  [16 15 14 13]]

print(arr[:,::-2])
# [[ 4  2]
#  [ 8  6]
#  [12 10]
#  [16 14]]

print(arr[0:2,0:2])
# [[1 2 ]
#  [5 6 ]]

print(arr[2:,0:2])
# [[ 9 10]
#  [13 14]]

print(arr[2:,2:])
# [[11 12]
#  [15 16]]

#scaler arithmatic:  linear (single digits)
array = np.array([1,2,3,4])
print(array+1) #add element by one -> [2 3 4 5]
print(array-2)  #[-1  0  1  2]
print(array*3)  #[ 3  6  9 12]
print(array / 2) #[0.5 1.  1.5 2. ]
print(array ** 5) #[   1   32  243 1024]

#vactorized math function
import numpy as np
array = np.array([1,2,3,4])
print(np.sqrt(array)) #[1.         1.41421356 1.73205081 2.        ]

array = np.array([1.01,2.3,3.99])
print(np.round(array)) #[1. 2. 3.]
print(np.floor(array)) #[1. 2. 3.] round lower
print(np.ceil(array)) #[2. 3. 4.] round upper
print(np.pi) #3.141592653589793

#exercise
import numpy as np
radii = np.array([1,2,3,4])
#Area of circle
print(np.pi*radii**2) #[ 3.14159265 12.56637061 28.27433388 50.26548246]

#element-wise arithmatics
import numpy as np
array1 = np.array([1,2,3,4])
array2 = np.array([5,6,7,8])
print(array1 + array2) #[ 6  8 10 12]
print(array1 - array2) #[-4 -4 -4 -4]
print(array1 * array2) #[ 5 12 21 32]
print(array1 / array2) #[0.2        0.33333333 0.42857143 0.5       ]
print(array1 ** array2) #[    1    64  2187 65536]

#comparison operator
import numpy as np
scores = np.array([91,55,78,100,62])
print(scores< 60) #[False  True False False False]
print(scores > 60) #[ True  True  True  True  True]
print(scores >= 60) #[ True  True  True  True  True]
print(scores <= 60) #[False False False False False]

scores[scores<60] = 0
print(scores) #[ 91   0  78 100  62]

#broadcasting: to perform operation on array by different shape by virtually expanding their dimensions
import numpy as np
arr1 = np.array([[1,2,3,4]])
arr2 = np.array([[1],[2],[3],[4]])
print (arr1.shape)
print(arr2.shape)
# (1, 4)
# (4, 1)
# to match these dimesions
print(arr1*arr2)
# [[ 1  2  3  4]
#  [ 2  4  6  8]
#  [ 3  6  9 12]
#  [ 4  8 12 16]]

import numpy as np
arr1 = np.array([[1,2,3,4],
                 [5,6,7,8],
                 [9,10,11,12],
                 [13,14,15,16]])
arr2 = np.array([[1],[2],[3],[4]])
print(arr1.shape)
print(arr2.shape)
# (4, 4)
# (4, 1)
print(arr1*arr2)
# [[ 1  2  3  4]
#  [10 12 14 16]
#  [27 30 33 36]
#  [52 56 60 64]]

# multiplication table between 1 to 10
import numpy as np
array1 = np.array([[1,2,3,4,5,6,7,8,9,10]])
array2 = np.array([[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]])
print(array1 * array2)
# [[  1   2   3   4   5   6   7   8   9  10]
#  [  2   4   6   8  10  12  14  16  18  20]
#  [  3   6   9  12  15  18  21  24  27  30]
#  [  4   8  12  16  20  24  28  32  36  40]
#  [  5  10  15  20  25  30  35  40  45  50]
#  [  6  12  18  24  30  36  42  48  54  60]
#  [  7  14  21  28  35  42  49  56  63  70]
#  [  8  16  24  32  40  48  56  64  72  80]
#  [  9  18  27  36  45  54  63  72  81  90]
#  [ 10  20  30  40  50  60  70  80  90 100]]

# Aggregate function: summarize data and typically  return single value.
array = np.array([[1,2,3,4,5],
                  [6,7,8,9,10]])
print(np.sum(array)) #55
print(np.mean(array)) #5.5
print(np.std(array)) #standard deviation->2.8722813232690143
print(np.var(array)) #variance-> square of std-> 8.25
print(np.min(array)) #1
print(np.max(array)) #10
print(np.argmin(array)) #0 position of minimum value
print(np.argmax(array)) #9 position of maximum value

print(np.sum(array,axis = 0)) #[ 7  9 11 13 15] sum of columns by axis = 0
print(np.sum(array,axis=1)) #[15 40] -> sum of rows by axis = 1

# Filtering: refers to the process of selecting elements from an array that match a given condition.
import numpy as np
ages = np.array([[21,17,18,23,73,98,12],
                [12,32,56,78,19,16,14]])
teens = ages[ages<18] #[17 12 12 16 14]
adults = ages[(ages<=18) & (ages < 65)] #and operator -> [17 18 12 12 16 14]
adults = ages[(ages < 18) | (ages >= 65)] #or operator -> [17 73 98 12 12 78 16 14]
seniors = ages[(ages >= 60)] #[73 98 12
evens = ages[(ages % 2 == 0)] #[18 98 12 12 32 56 78 16 14]
odds = ages[(ages % 2 != 0)] #[21 17 23 73 19]
# print(teens)
# print(adults)
# print(seniors)
# print(evens)
# print(odds)

# to preserve the shape of array we use the where()

adults = np.where (ages > 18,ages,0) #1st is condition, 2nd is array, 3rd is boolean
print(adults)
# [[21  0  0 23 73 98  0]
#  [ 0 32 56 78 19  0  0]]